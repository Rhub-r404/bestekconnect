import _classCallCheck from '@babel/runtime-corejs3/helpers/classCallCheck';
import _createClass from '@babel/runtime-corejs3/helpers/createClass';
import _sliceInstanceProperty from '@babel/runtime-corejs3/core-js/instance/slice';
import { Inflate } from 'pako';
import _globalThis from '@babel/runtime-corejs3/core-js/global-this';
import JSBI$1 from 'jsbi';
import _inherits from '@babel/runtime-corejs3/helpers/inherits';
import _possibleConstructorReturn from '@babel/runtime-corejs3/helpers/possibleConstructorReturn';
import _getPrototypeOf from '@babel/runtime-corejs3/helpers/getPrototypeOf';
import _Object$create from '@babel/runtime-corejs3/core-js/object/create';
import _endsWithInstanceProperty from '@babel/runtime-corejs3/core-js/instance/ends-with';
import _trimInstanceProperty from '@babel/runtime-corejs3/core-js/instance/trim';
import _Date$now from '@babel/runtime-corejs3/core-js/date/now';
import _forEachInstanceProperty from '@babel/runtime-corejs3/core-js/instance/for-each';
import _Object$keys from '@babel/runtime-corejs3/core-js/object/keys';
import _Reflect$construct from '@babel/runtime-corejs3/core-js/reflect/construct';
import { TransformStream } from 'web-streams-polyfill/ponyfill';

// eslint-disable-next-line import/no-mutable-exports
let jsbi;

/**
 * If BigInt is natively supported, change JSBI to use native expressions
 * @see https://github.com/GoogleChromeLabs/jsbi/blob/master/jsbi.d.ts
 * @see https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint/blob/master/src/index.js
 */
if (_globalThis.BigInt) {
  jsbi = {};

  // constructor
  jsbi.BigInt = a => BigInt(a);

  // note: JSBI toString is already the same: a.toString()
  jsbi.toNumber = a => Number(a);

  // binary functions to expressions
  jsbi.add = (a, b) => a + b;
  jsbi.subtract = (a, b) => a - b;
  jsbi.multiply = (a, b) => a * b;
  jsbi.divide = (a, b) => a / b;
  jsbi.remainder = (a, b) => a % b;
  jsbi.exponentiate = (a, b) => a ** b;
  jsbi.leftShift = (a, b) => a << b;
  jsbi.signedRightShift = (a, b) => a >> b;
  jsbi.bitwiseAnd = (a, b) => a & b;
  jsbi.bitwiseOr = (a, b) => a | b;
  jsbi.bitwiseXor = (a, b) => a ^ b;
  jsbi.equal = (a, b) => a === b;
  jsbi.notEqual = (a, b) => a !== b;
  jsbi.lessThan = (a, b) => a < b;
  jsbi.lessThanOrEqual = (a, b) => a <= b;
  jsbi.greaterThan = (a, b) => a > b;
  jsbi.greaterThanOrEqual = (a, b) => a >= b;
  jsbi.EQ = (a, b) => a === b;
  jsbi.NE = (a, b) => a !== b;
  jsbi.LT = (a, b) => a < b;
  jsbi.LE = (a, b) => a <= b;
  jsbi.GT = (a, b) => a > b;
  jsbi.GE = (a, b) => a >= b;
  jsbi.ADD = (a, b) => a + b;

  // unary functions to expressions
  jsbi.unaryMinus = a => -a;
  jsbi.bitwiseNot = a => ~a;

  // static methods
  jsbi.asIntN = (a, b) => BigInt.asIntN(a, b);
  jsbi.asUintN = (a, b) => BigInt.asUintN(a, b);
} else {
  jsbi = JSBI$1;
}
var JSBI = jsbi;

/* eslint-disable no-param-reassign */
let Crc32 = /*#__PURE__*/function () {
  function Crc32() {
    _classCallCheck(this, Crc32);
    this.crc = -1;
  }
  _createClass(Crc32, [{
    key: "append",
    value: function append(data) {
      let crc = this.crc | 0;
      const {
        table
      } = this;
      for (let offset = 0, len = data.length | 0; offset < len; offset++) {
        crc = crc >>> 8 ^ table[(crc ^ data[offset]) & 0xff];
      }
      this.crc = crc;
    }
  }, {
    key: "get",
    value: function get() {
      return (this.crc ^ -1) >>> 0;
    }
  }]);
  return Crc32;
}();
Crc32.prototype.table = ((table, i, j, t) => {
  for (i = 0; i < 256; i++) {
    t = i;
    for (j = 0; j < 8; j++) {
      t = t & 1 ? t >>> 1 ^ 0xedb88320 : t >>> 1;
    }
    table[i] = t;
  }
  return table;
})([], 0, 0, 0);
/* eslint-enable no-param-reassign */

const ERR_BAD_FORMAT = 'File format is not recognized.';
const ZIP_COMMENT_MAX = 65536;
const EOCDR_MIN = 22;
const EOCDR_MAX = EOCDR_MIN + ZIP_COMMENT_MAX;
const MAX_VALUE_32BITS = 0xffffffff;
const decoder = new TextDecoder();
const uint16e = (b, n) => b[n] | b[n + 1] << 8;
let Entry = /*#__PURE__*/function () {
  function Entry(dataView, fileLike) {
    _classCallCheck(this, Entry);
    if (dataView.getUint32(0) !== 0x504b0102) {
      throw new Error('ERR_BAD_FORMAT');
    }
    const dv = dataView;
    this.dataView = dv;
    this._fileLike = fileLike;
    this._extraFields = {};
    for (let i = 46 + this.filenameLength; i < dv.byteLength;) {
      var _context;
      const id = dv.getUint16(i, true);
      const len = dv.getUint16(i + 2, true);
      const start = dv.byteOffset + i + 4;
      this._extraFields[id] = new DataView(_sliceInstanceProperty(_context = dv.buffer).call(_context, start, start + len));
      i += len + 4;
    }
  }
  _createClass(Entry, [{
    key: "versionMadeBy",
    get: function () {
      return this.dataView.getUint16(4, true);
    }
  }, {
    key: "versionNeeded",
    get: function () {
      return this.dataView.getUint16(6, true);
    }
  }, {
    key: "bitFlag",
    get: function () {
      return this.dataView.getUint16(8, true);
    }
  }, {
    key: "encrypted",
    get: function () {
      return (this.bitFlag & 0x0001) === 0x0001;
    }
  }, {
    key: "compressionMethod",
    get: function () {
      return this.dataView.getUint16(10, true);
    }
  }, {
    key: "crc32",
    get: function () {
      return this.dataView.getUint32(16, true);
    }
  }, {
    key: "compressedSize",
    get: function () {
      return this.dataView.getUint32(20, true);
    }
  }, {
    key: "filenameLength",
    get: function () {
      return this.dataView.getUint16(28, true);
    }
  }, {
    key: "extraFieldLength",
    get: function () {
      return this.dataView.getUint16(30, true);
    }
  }, {
    key: "commentLength",
    get: function () {
      return this.dataView.getUint16(32, true);
    }
  }, {
    key: "diskNumberStart",
    get: function () {
      return this.dataView.getUint16(34, true);
    }
  }, {
    key: "internalFileAttributes",
    get: function () {
      return this.dataView.getUint16(36, true);
    }
  }, {
    key: "externalFileAttributes",
    get: function () {
      return this.dataView.getUint32(38, true);
    }
  }, {
    key: "directory",
    get: function () {
      return !!(this.dataView.getUint8(38) & 16);
    }
  }, {
    key: "offset",
    get: function () {
      return this.dataView.getUint32(42, true);
    }
  }, {
    key: "zip64",
    get: function () {
      return this.dataView.getUint32(24, true) === MAX_VALUE_32BITS;
    }
  }, {
    key: "comment",
    get: function () {
      const dv = this.dataView;
      const uint8 = new Uint8Array(dv.buffer, dv.byteOffset + this.filenameLength + this.extraFieldLength + 46, this.commentLength);
      return decoder.decode(uint8);
    }

    // File like IDL methods
  }, {
    key: "lastModifiedDate",
    get: function () {
      const t = this.dataView.getUint32(12, true);
      return new Date(
      // Date.UTC(
      (t >> 25 & 0x7f) + 1980,
      // year
      (t >> 21 & 0x0f) - 1,
      // month
      t >> 16 & 0x1f,
      // day
      t >> 11 & 0x1f,
      // hour
      t >> 5 & 0x3f,
      // minute
      (t & 0x1f) << 1) // ),
      ;
    }
  }, {
    key: "lastModified",
    get: function () {
      return +this.lastModifiedDate;
    }
  }, {
    key: "name",
    get: function () {
      if (!this.bitFlag && this._extraFields && this._extraFields[0x7075]) {
        var _context2;
        return decoder.decode(_sliceInstanceProperty(_context2 = this._extraFields[0x7075].buffer).call(_context2, 5));
      }
      const dv = this.dataView;
      const uint8 = new Uint8Array(dv.buffer, dv.byteOffset + 46, this.filenameLength);
      return decoder.decode(uint8);
    }
  }, {
    key: "size",
    get: function () {
      const size = this.dataView.getUint32(24, true);
      return size === MAX_VALUE_32BITS ? this._extraFields[1].getUint8(0) : size;
    }
  }, {
    key: "stream",
    value: function stream() {
      const self = this;
      const crc = new Crc32();
      let inflator;
      const onEnd = ctrl => crc.get() === self.crc32 ? ctrl.close() : ctrl.error(new Error("The crc32 checksum don't match"));
      return new ReadableStream({
        async start(ctrl) {
          var _context3, _context4;
          // Need to read local header to get fileName + extraField length
          // Since they are not always the same length as in central dir...
          const ab = await _sliceInstanceProperty(_context3 = self._fileLike).call(_context3, self.offset + 26, self.offset + 30).arrayBuffer();
          const bytes = new Uint8Array(ab);
          const localFileOffset = uint16e(bytes, 0) + uint16e(bytes, 2) + 30;
          const start = self.offset + localFileOffset;
          const end = start + self.compressedSize;
          this.reader = _sliceInstanceProperty(_context4 = self._fileLike).call(_context4, start, end).stream().getReader();
          if (self.compressionMethod) {
            inflator = new Inflate({
              raw: true
            });
            inflator.onData = chunk => {
              crc.append(chunk);
              ctrl.enqueue(chunk);
            };
            inflator.onEnd = () => onEnd(ctrl);
          }
        },
        async pull(ctrl) {
          const v = await this.reader.read();
          if (inflator && !v.done) {
            inflator.push(v.value);
          } else if (v.done) {
            onEnd(ctrl);
          } else {
            ctrl.enqueue(v.value);
            crc.append(v.value);
          }
        }
      });
    }
  }, {
    key: "arrayBuffer",
    value: function arrayBuffer() {
      return new Response(this.stream()).arrayBuffer().catch(e => {
        throw new Error(`Failed to read Entry\n${e}`);
      });
    }
  }, {
    key: "text",
    value: function text() {
      return new Response(this.stream()).text().catch(e => {
        throw new Error(`Failed to read Entry\n${e}`);
      });
    }
  }, {
    key: "file",
    value: function file() {
      return new Response(this.stream()).blob().then(blob => new File([blob], this.name, {
        lastModified: this.lastModified
      })).catch(e => {
        throw new Error(`Failed to read Entry\n${e}`);
      });
    }
  }]);
  return Entry;
}();
/**
 * Get a BigInt 64 from a DataView
 *
 * @param {DataView} view a dataview
 * @param {number} position the position
 * @param {boolean} littleEndian whether this uses littleEndian encoding
 * @returns BigInt
 */
function getBigInt64(view, position) {
  let littleEndian = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  if ('getBigInt64' in DataView.prototype) {
    return view.getBigInt64(position, littleEndian);
  }
  let value = JSBI.BigInt(0);
  const isNegative = (view.getUint8(position + (littleEndian ? 7 : 0)) & 0x80) > 0;
  let carrying = true;
  for (let i = 0; i < 8; i++) {
    let byte = view.getUint8(position + (littleEndian ? i : 7 - i));
    if (isNegative) {
      if (carrying) {
        if (byte !== 0x00) {
          byte = ~(byte - 1) & 0xff;
          carrying = false;
        }
      } else {
        byte = ~byte & 0xff;
      }
    }
    value = JSBI.add(value, JSBI.multiply(JSBI.BigInt(byte), JSBI.exponentiate(JSBI.BigInt(256), JSBI.BigInt(i))));
  }
  if (isNegative) {
    value = JSBI.unaryMinus(value);
  }
  return value;
}
async function* Reader(file) {
  // Seek EOCDR - "End of central directory record" is the last part of a zip archive, and is at least 22 bytes long.
  // Zip file comment is the last part of EOCDR and has max length of 64KB,
  // so we only have to search the last 64K + 22 bytes of a archive for EOCDR signature (0x06054b50).
  if (file.size < EOCDR_MIN) throw new Error(ERR_BAD_FORMAT);

  // seek last length bytes of file for EOCDR
  async function doSeek(length) {
    const ab = await _sliceInstanceProperty(file).call(file, file.size - length).arrayBuffer();
    const bytes = new Uint8Array(ab);
    for (let i = bytes.length - EOCDR_MIN; i >= 0; i--) {
      if (bytes[i] === 0x50 && bytes[i + 1] === 0x4b && bytes[i + 2] === 0x05 && bytes[i + 3] === 0x06) {
        return new DataView(bytes.buffer, i, EOCDR_MIN);
      }
    }
    return null;
  }

  // In most cases, the EOCDR is EOCDR_MIN bytes long
  let dv = (await doSeek(EOCDR_MIN)) || (await doSeek(Math.min(EOCDR_MAX, file.size)));
  if (!dv) throw new Error(ERR_BAD_FORMAT);
  let fileslength = dv.getUint16(8, true);
  let centralDirSize = dv.getUint32(12, true);
  let centralDirOffset = dv.getUint32(16, true);
  // const fileCommentLength = dv.getUint16(20, true);

  const isZip64 = centralDirOffset === MAX_VALUE_32BITS;
  if (isZip64) {
    const l = -dv.byteLength - 20;
    dv = new DataView(await _sliceInstanceProperty(file).call(file, l, -dv.byteLength).arrayBuffer());

    // const signature = dv.getUint32(0, true) // 4 bytes
    // const diskWithZip64CentralDirStart = dv.getUint32(4, true) // 4 bytes
    const relativeOffsetEndOfZip64CentralDir = JSBI.toNumber(getBigInt64(dv, 8, true)); // 8 bytes
    // const numberOfDisks = dv.getUint32(16, true) // 4 bytes

    const zip64centralBlob = _sliceInstanceProperty(file).call(file, relativeOffsetEndOfZip64CentralDir, l);
    dv = new DataView(await zip64centralBlob.arrayBuffer());
    // const zip64EndOfCentralSize = dv.getBigInt64(4, true)
    // const diskNumber = dv.getUint32(16, true)
    // const diskWithCentralDirStart = dv.getUint32(20, true)
    // const centralDirRecordsOnThisDisk = dv.getBigInt64(24, true)
    fileslength = JSBI.toNumber(getBigInt64(dv, 32, true));
    centralDirSize = JSBI.toNumber(getBigInt64(dv, 40, true));
    centralDirOffset = JSBI.toNumber(getBigInt64(dv, 48, true));
  }
  if (centralDirOffset < 0 || centralDirOffset >= file.size) {
    throw new Error(ERR_BAD_FORMAT);
  }
  const start = centralDirOffset;
  const end = centralDirOffset + centralDirSize;
  const blob = _sliceInstanceProperty(file).call(file, start, end);
  const bytes = new Uint8Array(await blob.arrayBuffer());
  for (let i = 0, index = 0; i < fileslength; i++) {
    const size = uint16e(bytes, index + 28) +
    // filenameLength
    uint16e(bytes, index + 30) +
    // extraFieldLength
    uint16e(bytes, index + 32) +
    // commentLength
    46;
    if (index + size > bytes.length) {
      throw new Error('Invalid ZIP file.');
    }
    yield new Entry(new DataView(bytes.buffer, index, size), file);
    index += size;
  }
}

var _globalThis$WebStream;
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
const encoder = new TextEncoder();
let ZipTransformer = /*#__PURE__*/function () {
  function ZipTransformer() {
    _classCallCheck(this, ZipTransformer);
    /* The files zipped */
    this.files = _Object$create(null);
    /* The current position of the zipped output stream, in bytes */
    this.offset = JSBI.BigInt(0);
  }

  /**
   * Transforms a stream of files into one zipped file
   *
   * @param  {File}  entry [description]
   * @param  {ReadableStreamDefaultController}  ctrl
   * @return {Promise}       [description]
   */
  _createClass(ZipTransformer, [{
    key: "transform",
    value: async function transform(entry, ctrl) {
      var _context, _context2, _context3, _context4;
      // Set the File name, ensuring that if it's a directory, it ends with `/`
      const name = entry.directory && !_endsWithInstanceProperty(_context = _trimInstanceProperty(_context2 = entry.name).call(_context2)).call(_context, '/') ? `${_trimInstanceProperty(_context3 = entry.name).call(_context3)}/` : _trimInstanceProperty(_context4 = entry.name).call(_context4);

      // Abort if this a file with this name already exists
      if (this.files[name]) ctrl.abort(new Error('File already exists.'));

      // TextEncode the name
      const nameBuf = encoder.encode(name);
      this.files[name] = {
        directory: !!entry.directory,
        nameBuf,
        offset: this.offset,
        comment: encoder.encode(entry.comment || ''),
        compressedLength: JSBI.BigInt(0),
        uncompressedLength: JSBI.BigInt(0),
        header: new Uint8Array(26)
      };
      const zipObject = this.files[name];
      const {
        header
      } = zipObject;

      // Set the date, with fallback to current date
      const date = new Date(typeof entry.lastModified === 'undefined' ? _Date$now() : entry.lastModified);

      // The File header DataView
      const hdv = new DataView(header.buffer);
      const data = new Uint8Array(30 + nameBuf.length);
      hdv.setUint32(0, 0x14000808);
      hdv.setUint16(6, (date.getHours() << 6 | date.getMinutes()) << 5 | date.getSeconds() / 2, true);
      hdv.setUint16(8, (date.getFullYear() - 1980 << 4 | date.getMonth() + 1) << 5 | date.getDate(), true);
      hdv.setUint16(22, nameBuf.length, true);
      data.set([80, 75, 3, 4]);
      data.set(header, 4);
      data.set(nameBuf, 30);
      this.offset = JSBI.add(this.offset, JSBI.BigInt(data.length));
      ctrl.enqueue(data);
      const footer = new Uint8Array(16);
      footer.set([80, 75, 7, 8]);
      if (entry.stream) {
        zipObject.crc = new Crc32();
        const reader = entry.stream().getReader();
        while (true) {
          const it = await reader.read();
          if (it.done) break;
          const chunk = it.value;
          zipObject.crc.append(chunk);
          zipObject.uncompressedLength = JSBI.add(zipObject.uncompressedLength, JSBI.BigInt(chunk.length));
          zipObject.compressedLength = JSBI.add(zipObject.compressedLength, JSBI.BigInt(chunk.length));
          ctrl.enqueue(chunk);
        }
        hdv.setUint32(10, zipObject.crc.get(), true);
        hdv.setUint32(14, JSBI.toNumber(zipObject.compressedLength), true);
        hdv.setUint32(18, JSBI.toNumber(zipObject.uncompressedLength), true);
        footer.set(header.subarray(10, 22), 4);
      }
      hdv.setUint16(22, nameBuf.length, true);
      this.offset = JSBI.add(this.offset, JSBI.add(zipObject.compressedLength, JSBI.BigInt(16)));
      ctrl.enqueue(footer);
    }

    /**
     * @param  {ReadableStreamDefaultController} ctrl
     */
  }, {
    key: "flush",
    value: function flush(ctrl) {
      var _context5, _context6;
      let length = 0;
      let index = 0;
      let file;
      _forEachInstanceProperty(_context5 = _Object$keys(this.files)).call(_context5, fileName => {
        file = this.files[fileName];
        length += 46 + file.nameBuf.length + file.comment.length;
      });
      const data = new Uint8Array(length + 22);
      const dv = new DataView(data.buffer);
      _forEachInstanceProperty(_context6 = _Object$keys(this.files)).call(_context6, fileName => {
        file = this.files[fileName];
        dv.setUint32(index, 0x504b0102);
        dv.setUint16(index + 4, 0x1400);
        dv.setUint16(index + 32, file.comment.length, true);
        dv.setUint8(index + 38, file.directory ? 16 : 0);
        dv.setUint32(index + 42, JSBI.toNumber(file.offset), true);
        data.set(file.header, index + 6);
        data.set(file.nameBuf, index + 46);
        data.set(file.comment, index + 46 + file.nameBuf.length);
        index += 46 + file.nameBuf.length + file.comment.length;
      });
      dv.setUint32(index, 0x504b0506);
      dv.setUint16(index + 8, _Object$keys(this.files).length, true);
      dv.setUint16(index + 10, _Object$keys(this.files).length, true);
      dv.setUint32(index + 12, length, true);
      dv.setUint32(index + 16, JSBI.toNumber(this.offset), true);
      ctrl.enqueue(data);

      // cleanup
      this.files = _Object$create(null);
      this.offset = 0;
    }
  }]);
  return ZipTransformer;
}();
const ModernTransformStream = _globalThis.TransformStream || ((_globalThis$WebStream = _globalThis.WebStreamsPolyfill) === null || _globalThis$WebStream === void 0 ? void 0 : _globalThis$WebStream.TransformStream) || TransformStream;
let Writer = /*#__PURE__*/function (_ModernTransformStrea) {
  _inherits(Writer, _ModernTransformStrea);
  var _super = _createSuper(Writer);
  function Writer() {
    _classCallCheck(this, Writer);
    return _super.call(this, new ZipTransformer());
  }
  return _createClass(Writer);
}(ModernTransformStream);

export { Reader, Writer };
